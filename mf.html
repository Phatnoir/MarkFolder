<!DOCTYPE html>
<html lang="en">
<head>
<link rel="icon" type="image/png" href="favicon.png">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Markdown Folder</title>
<style>
  body { font-family: Arial, sans-serif; margin: 0; padding: 1rem; background: #f4f4f4; color: #222; transition: background 0.3s, color 0.3s; }
  .dark-mode { background: #121212; color: #ddd; }
  .top-controls { display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 1rem; }
  .file-controls, .view-controls, .category-controls { 
    display: flex; 
    flex-wrap: wrap; 
    gap: 0.5rem;
    background: #e0e0e0;
    padding: 0.5rem;
    border-radius: 5px;
    margin-bottom: 0.5rem;
  }
  .dark-mode .file-controls, .dark-mode .view-controls, .dark-mode .category-controls { 
    background: #2a2a2a; 
  }
  textarea { 
    width: 100%; 
    height: 200px; 
    margin-bottom: 1rem; 
    padding: 0.5rem;
    font-family: monospace;
    border-radius: 5px;
  }
  #rendered { 
    padding: 1rem; 
    background: #fff; 
    border: 1px solid #ccc; 
    border-radius: 5px; 
    min-height: 200px;
  }
  .dark-mode #rendered { background: #1e1e1e; border-color: #555; }
  button { 
    margin: 0; 
    padding: 0.5rem 0.8rem;
    border: none;
    border-radius: 4px;
    background: #4a90e2;
    color: white;
    cursor: pointer;
    font-size: 0.9rem;
  }
  button:hover { background: #357ab8; }
  select { 
    padding: 0.5rem;
    border-radius: 4px;
    border: 1px solid #ccc;
  }
  input[type="checkbox"] { transform: scale(1.2); margin-right: 0.5rem; }
  a { color: #4a90e2; }
  .dark-mode a { color: #7ab6ff; }
  h1 { color: #333; }
  .dark-mode h1 { color: #eee; }
  .file-input-wrapper {
    position: relative;
    overflow: hidden;
    display: inline-block;
  }
  .file-input-wrapper input[type=file] {
    position: absolute;
    left: 0;
    top: 0;
    opacity: 0;
    cursor: pointer;
    width: 100%;
    height: 100%;
  }
  .status-bar {
    margin-top: 0.5rem;
    font-size: 0.9rem;
    color: #666;
  }
  .dark-mode .status-bar { color: #aaa; }
  .categories-list {
    margin-top: 1rem;
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
  }
  .category-tag {
    padding: 0.3rem 0.6rem;
    background: #ddd;
    border-radius: 20px;
    font-size: 0.8rem;
    cursor: pointer;
    transition: background 0.3s;
  }
  .dark-mode .category-tag { background: #444; }
  .category-tag:hover { background: #ccc; }
  .dark-mode .category-tag:hover { background: #555; }
  .category-tag.active { background: #4a90e2; color: white; }
  .dark-mode .category-tag.active { background: #2a6cb7; }
  #fileMetadata {
    margin-bottom: 0.5rem;
    font-size: 0.9rem;
  }
  .modal-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }
  .modal {
    background-color: #fff;
    padding: 2rem;
    border-radius: 5px;
    max-width: 600px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
  }
  .dark-mode .modal {
    background-color: #1e1e1e;
    color: #ddd;
  }
  .modal-buttons {
    margin-top: 1rem;
    text-align: right;
  }
  .file-item {
    margin: 0.5rem 0;
    padding: 0.5rem;
    border-radius: 4px;
    background: #f8f8f8;
    display: flex;
    align-items: center;
  }
  .dark-mode .file-item {
    background: #2a2a2a;
  }
  .file-item-info {
    margin-left: 0.5rem;
    flex-grow: 1;
  }
  .file-item-category {
    font-size: 0.8rem;
    color: #4a90e2;
    margin-left: 0.5rem;
  }
  /* New styles for editor visibility toggle */
  .toggle-editor-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 10;
    padding: 0.3rem 0.6rem;
    font-size: 0.8rem;
    opacity: 0.7;
  }
  .toggle-editor-btn:hover {
    opacity: 1;
  }
  .editor-container {
    position: relative;
  }
  .hidden {
    display: none !important;
  }
  /* New styles for preview-only mode */
  .preview-only-mode #rendered {
    width: 100%;
    margin-left: 0;
  }
  .category-container {
	margin-bottom: 1rem;
  }
  .category-files {
    display: flex;
    flex-wrap: wrap;
	gap: 0.5rem;
	margin-top: 0.5rem;
	margin-left: 1rem;
	padding: 0.5rem;
	background: rgba(0,0,0,0.05);
	border-radius: 8px;
  }
  .dark-mode .category-files {
    background: rgba(255,255,255,0.05);
  }
  .file-bubble {
	padding: 0.3rem 0.6rem;
	background: #e0e0e0;
	border-radius: 20px;
	font-size: 0.8rem;
	cursor: pointer;
	max-width: 200px;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
  }
  .dark-mode .file-bubble {
    background: #333;
  }
  .file-bubble:hover {
	background: #4a90e2;
	color: white;
  }
  .file-bubble.empty {
	background: #ddd;
	color: #777;
	cursor: default;
  }
  .dark-mode .file-bubble.empty {
	background: #444;
	color: #999;
  }
  .hidden {
	display: none !important;
  }
</style>
</head>
<body>

<h1>Markdown Folder</h1>

<div class="top-controls">
  <div class="view-controls">
    <button onclick="toggleDarkMode()">Toggle Dark Mode</button>
    <button onclick="toggleSideBySide()">Toggle View Mode</button>
    <button id="toggleEditorBtn" onclick="toggleEditor()">Hide Editor</button>
  </div>
  
  <div class="file-controls">
    <div class="file-input-wrapper">
      <button>Upload MD File</button>
      <input type="file" accept=".md" id="fileInput" onchange="handleFileUpload(event)">
    </div>
    <button onclick="saveCurrentFile()">Save File</button>
    <button onclick="loadSavedFile()">Load File</button>
    <button onclick="deleteSavedFile()">Delete File</button>
    <button onclick="exportCurrentFile()">Export Markdown</button>
    <button onclick="cleanupStorage()">Cleanup Files</button>
    <select id="savedFilesDropdown"></select>
  </div>
  
  <div class="category-controls">
    <button onclick="createCategory()">Create Category</button>
    <button onclick="deleteCategory()">Delete Category</button>
    <select id="categoryDropdown" onchange="filterByCategory()">
      <option value="all">All Categories</option>
    </select>
  </div>
</div>

<div id="fileMetadata"></div>
<div id="editor-container" class="editor-container">
  <textarea id="markdownInput" placeholder="Paste your Markdown here..."></textarea>
  <div id="rendered"></div>
</div>

<div class="categories-list" id="categoriesList"></div>
<div class="status-bar" id="statusBar">Ready</div>

<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script>
const markdownInput = document.getElementById('markdownInput');
const rendered = document.getElementById('rendered');
const savedFilesDropdown = document.getElementById('savedFilesDropdown');
const categoryDropdown = document.getElementById('categoryDropdown');
const categoriesList = document.getElementById('categoriesList');
const statusBar = document.getElementById('statusBar');
const fileMetadata = document.getElementById('fileMetadata');
const editorContainer = document.getElementById('editor-container');
const toggleEditorBtn = document.getElementById('toggleEditorBtn');

let currentFile = '';
let currentCategory = 'all';
let sideBySideMode = false;
let hasUnsavedChanges = false;
let originalContent = '';
let editorVisible = true;

// Store categories in localStorage
const CATEGORIES_STORAGE_KEY = 'md_categories';

// Initialize categories from storage or default
function initializeCategories() {
  // Default categories
  const defaultCategories = ['Uncategorized'];
  
  // Try to get existing categories from localStorage
  let savedCategories = localStorage.getItem(CATEGORIES_STORAGE_KEY);
  if (savedCategories) {
    try {
      return JSON.parse(savedCategories);
    } catch (e) {
      console.error('Error parsing categories:', e);
      return defaultCategories;
    }
  }
  
  // If no categories exist yet, save the defaults
  localStorage.setItem(CATEGORIES_STORAGE_KEY, JSON.stringify(defaultCategories));
  return defaultCategories;
}

// Function to save categories to localStorage
function saveCategories(categories) {
  localStorage.setItem(CATEGORIES_STORAGE_KEY, JSON.stringify(categories));
}

// Initialize display mode
function initializeDisplayMode() {
  const savedMode = localStorage.getItem('sideBySideMode') === 'true';
  if (savedMode) {
    toggleSideBySide();
  }
  
  // Check if editor was hidden previously
  const editorHidden = localStorage.getItem('editorHidden') === 'true';
  if (editorHidden) {
    toggleEditor(false);
  }
}

function toggleSideBySide() {
  sideBySideMode = !sideBySideMode;
  localStorage.setItem('sideBySideMode', sideBySideMode);
  
  if (sideBySideMode) {
    editorContainer.style.display = 'flex';
    editorContainer.style.gap = '1rem';
    markdownInput.style.width = '48%';
    rendered.style.width = '48%';
    rendered.style.marginLeft = '1%';
  } else {
    editorContainer.style.display = 'block';
    markdownInput.style.width = '100%';
    rendered.style.width = '100%';
    rendered.style.marginLeft = '0';
  }
  
  // Adjust based on editor visibility
  updateEditorVisibility();
}

// Replace the existing toggleEditor function
function toggleEditor(animate = true) {
  editorVisible = !editorVisible;
  localStorage.setItem('editorHidden', !editorVisible);
  
  // Update button text
  toggleEditorBtn.textContent = editorVisible ? 'Hide Editor' : 'Show Editor';
  
  // Hide all file lists when toggling editor
  document.querySelectorAll('.category-files').forEach(el => {
    el.classList.add('hidden');
  });
  
  updateEditorVisibility();
}

// Separate function to update visibility based on current state
function updateEditorVisibility() {
  if (editorVisible) {
    markdownInput.classList.remove('hidden');
    if (sideBySideMode) {
      rendered.style.width = '48%';
      rendered.style.marginLeft = '1%';
    }
  } else {
    markdownInput.classList.add('hidden');
    rendered.style.width = '100%';
    rendered.style.marginLeft = '0';
  }
}

function renderMarkdown() {
  // First render the markdown normally with Marked
  marked.setOptions({
    gfm: true,         // GitHub-flavored markdown
    breaks: true,      // Allow single line breaks
    smartLists: true   // Smarter list behavior
  });
  
  // Initial rendering of the content
  rendered.innerHTML = marked.parse(markdownInput.value);
  
  // After Marked renders the HTML, find the list items that start with "- [ ]" or "- [x]"
  // and replace them with interactive checkboxes
  const listItems = rendered.querySelectorAll('li');
  listItems.forEach(li => {
    const text = li.innerHTML;
    
    // Check for unchecked boxes: "- [ ]"
    if (text.startsWith('- [ ]')) {
      li.innerHTML = `<input type="checkbox" onchange="saveCheckboxStates()"> ${text.substring(5).trim()}`;
    } 
    // Check for checked boxes: "- [x]"
    else if (text.toLowerCase().startsWith('- [x]')) {
      li.innerHTML = `<input type="checkbox" checked onchange="saveCheckboxStates()"> ${text.substring(5).trim()}`;
    }
  });
  
  // Also find and enable any disabled checkboxes that might have been created by Marked
  const disabledCheckboxes = rendered.querySelectorAll('input[type="checkbox"][disabled]');
  disabledCheckboxes.forEach(checkbox => {
    checkbox.disabled = false;
    checkbox.setAttribute('onchange', 'saveCheckboxStates()');
  });
  
  updateStatusBar();
  
  // Check for unsaved changes
  if (markdownInput.value !== originalContent) {  
    markUnsaved();
  } else {
    markSaved();
  }
}

markdownInput.addEventListener('input', renderMarkdown);

function markUnsaved() {
  if (!hasUnsavedChanges) {
    hasUnsavedChanges = true;
    document.title = '* Markdown Folder';
    showStatus('Unsaved changes');
  }
}

function markSaved() {
  hasUnsavedChanges = false;
  document.title = 'Markdown Folder';
  originalContent = markdownInput.value;
}

function showStatus(message, isError = false) {
  if (message) {
    statusBar.textContent = message;
    statusBar.style.color = isError ? '#e74c3c' : '';
    
    // Reset after 3 seconds
    setTimeout(() => {
      statusBar.style.color = '';
      updateStatusBar();
    }, 3000);
  }
}

function toggleDarkMode() {
  document.body.classList.toggle('dark-mode');
  localStorage.setItem('darkMode', document.body.classList.contains('dark-mode'));
}

function saveCheckboxStates() {
  console.log('[saveCheckboxStates] called');
  const checkboxes = rendered.querySelectorAll('input[type="checkbox"]');
  const states = Array.from(checkboxes).map(cb => cb.checked);
  if (currentFile) {
    const fileData = getFileData(currentFile);
    const prevStates = JSON.stringify(fileData.checkboxStates || []);
    const newStates = JSON.stringify(states);

    // Only update and mark unsaved if the checkbox state has truly changed
    if (prevStates !== newStates) {
      fileData.checkboxStates = states;
      localStorage.setItem('mdfile_' + currentFile, JSON.stringify(fileData));
      markUnsaved();
    }
  }
  updateStatusBar();
}

function restoreCheckboxStates() {
  if (currentFile) {
    const fileData = getFileData(currentFile);
    const states = fileData.checkboxStates || [];
    const checkboxes = rendered.querySelectorAll('input[type="checkbox"]');

    // Remove inline onchange attributes
    checkboxes.forEach(cb => {
      cb._originalOnChange = cb.getAttribute('onchange');
      cb.removeAttribute('onchange');
    });

    checkboxes.forEach((cb, idx) => cb.checked = states[idx] || false);

    // Restore onchange attributes
    checkboxes.forEach(cb => {
      if (cb._originalOnChange) {
        cb.setAttribute('onchange', cb._originalOnChange);
      }
      delete cb._originalOnChange;
    });
  }
}

function saveCurrentFile() {
  if (!markdownInput.value.trim()) {
    showStatus('Nothing to save', true);
    return;
  }

  let suggestedName = currentFile || 'untitled.md';
  let filename = prompt('Enter a file name:', suggestedName);
  
  if (!filename) return;
  if (!filename.endsWith('.md')) filename += '.md';

  // Check for existing file
  let baseFile = filename;
  let fileExists = localStorage.getItem('mdfile_' + filename);
  let i = 1;
  
  if (fileExists && baseFile === currentFile) {
    // We're saving changes to current file
    updateFileData(filename);
    showStatus(`Updated ${filename}`);
  } else if (fileExists) {
    // Ask to overwrite or auto-increment filename
    if (confirm(`File "${filename}" already exists. Overwrite?`)) {
      updateFileData(filename);
      showStatus(`Updated ${filename}`);
    } else {
      // Create new version with incremented name
      while (localStorage.getItem('mdfile_' + filename)) {
        filename = baseFile.replace(/(\(\d+\))?\.md$/, `(${i++}).md`);
      }
      showCategorySelector(filename, true); // Show category selector for new file
    }
  } else {
    // New file
    showCategorySelector(filename, true); // Show category selector for new file
  }
}

// New function to show a modal with category selection options
function showCategorySelector(filename, isNewFile) {
  // Create modal for category selection
  const modalContainer = document.createElement('div');
  modalContainer.className = 'modal-container';
  
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.maxWidth = '400px';
  
  const title = document.createElement('h3');
  title.textContent = isNewFile ? 'Select or create a category:' : 'Change category:';
  
  // Get all existing categories
  const categories = getCategories();
  
  // Create category list
  const categoryList = document.createElement('div');
  categoryList.style.maxHeight = '300px';
  categoryList.style.overflowY = 'auto';
  categoryList.style.margin = '1rem 0';
  
  // Add radio buttons for existing categories
  categories.forEach(category => {
    const categoryItem = document.createElement('div');
    categoryItem.className = 'file-item';
    
    const radio = document.createElement('input');
    radio.type = 'radio';
    radio.name = 'category-selection';
    radio.value = category;
    radio.id = `category-${category}`;
    if (category === 'Uncategorized') {
      radio.checked = true;
    }
    
    const label = document.createElement('label');
    label.htmlFor = `category-${category}`;
    label.textContent = category;
    label.style.marginLeft = '0.5rem';
    label.style.cursor = 'pointer';
    
    categoryItem.appendChild(radio);
    categoryItem.appendChild(label);
    categoryList.appendChild(categoryItem);
  });
  
  // Add option to create a new category
  const newCategoryItem = document.createElement('div');
  newCategoryItem.className = 'file-item';
  newCategoryItem.style.marginTop = '1rem';
  
  const newCategoryRadio = document.createElement('input');
  newCategoryRadio.type = 'radio';
  newCategoryRadio.name = 'category-selection';
  newCategoryRadio.value = 'new-category';
  newCategoryRadio.id = 'category-new';
  
  const newCategoryLabel = document.createElement('label');
  newCategoryLabel.htmlFor = 'category-new';
  newCategoryLabel.textContent = 'Create new category:';
  newCategoryLabel.style.marginLeft = '0.5rem';
  newCategoryLabel.style.cursor = 'pointer';
  
  const newCategoryInput = document.createElement('input');
  newCategoryInput.type = 'text';
  newCategoryInput.id = 'new-category-name';
  newCategoryInput.style.marginTop = '0.5rem';
  newCategoryInput.style.width = '100%';
  newCategoryInput.style.padding = '0.3rem';
  newCategoryInput.disabled = true;
  
  newCategoryItem.appendChild(newCategoryRadio);
  newCategoryItem.appendChild(newCategoryLabel);
  newCategoryItem.appendChild(newCategoryInput);
  categoryList.appendChild(newCategoryItem);
  
  // Add event listeners for the new category option
  newCategoryRadio.addEventListener('change', () => {
    newCategoryInput.disabled = !newCategoryRadio.checked;
    if (newCategoryRadio.checked) {
      newCategoryInput.focus();
    }
  });
  
  // Buttons
  const buttonGroup = document.createElement('div');
  buttonGroup.className = 'modal-buttons';
  
  const saveBtn = document.createElement('button');
  saveBtn.textContent = 'Save';
  saveBtn.style.marginRight = '0.5rem';
  
  const cancelBtn = document.createElement('button');
  cancelBtn.textContent = 'Cancel';
  
  buttonGroup.appendChild(saveBtn);
  buttonGroup.appendChild(cancelBtn);
  
  // Put it all together
  modal.appendChild(title);
  modal.appendChild(categoryList);
  modal.appendChild(buttonGroup);
  modalContainer.appendChild(modal);
  document.body.appendChild(modalContainer);
  
  // Event handlers
  cancelBtn.addEventListener('click', () => {
    document.body.removeChild(modalContainer);
  });
  
  saveBtn.addEventListener('click', () => {
    let selectedCategory = '';
    const selectedRadio = document.querySelector('input[name="category-selection"]:checked');
    
    if (selectedRadio.value === 'new-category') {
      selectedCategory = newCategoryInput.value.trim();
      if (!selectedCategory) {
        alert('Please enter a category name or select an existing category.');
        return;
      }
      
      // Add the new category to our categories list
      addCategory(selectedCategory);
    } else {
      selectedCategory = selectedRadio.value;
    }
    
    // Now save the file with the selected category
    if (isNewFile) {
      const fileData = {
        content: markdownInput.value,
        category: selectedCategory,
        checkboxStates: [],
        created: new Date().toISOString(),
        modified: new Date().toISOString()
      };
      
      localStorage.setItem('mdfile_' + filename, JSON.stringify(fileData));
      currentFile = filename;
      showStatus(`Saved as ${filename} in category "${selectedCategory}"`);
      updateFileMetadata(fileData);
    } else {
      // Updating category of existing file
      const fileData = getFileData(filename);
      fileData.category = selectedCategory;
      fileData.modified = new Date().toISOString();
      localStorage.setItem('mdfile_' + filename, JSON.stringify(fileData));
      updateFileMetadata(fileData);
      showStatus(`Updated category to "${selectedCategory}"`);
    }
    
    document.body.removeChild(modalContainer);
    updateSavedFilesList();
    updateCategoriesList();
    markSaved();
    
    // Hide the editor after saving
    if (editorVisible) {
      toggleEditor();
    }
  });
}

function saveNewFile(filename) {
  // Get category
  let category = prompt('Enter a category (or leave blank):', 'Uncategorized');
  if (category === null) return;
  if (!category) category = 'Uncategorized';
  
  // Add category if it's new
  addCategory(category);
  
  // Create and save file data
  const fileData = {
    content: markdownInput.value,
    category: category,
    checkboxStates: [],
    created: new Date().toISOString(),
    modified: new Date().toISOString()
  };
  
  localStorage.setItem('mdfile_' + filename, JSON.stringify(fileData));
  currentFile = filename;
  showStatus(`Saved as ${filename}`);
  updateFileMetadata(fileData);
}

function updateFileData(filename) {
  const fileData = getFileData(filename);
  fileData.content = markdownInput.value;
  fileData.modified = new Date().toISOString();
  localStorage.setItem('mdfile_' + filename, JSON.stringify(fileData));
  updateFileMetadata(fileData);
  originalContent = markdownInput.value; 
  renderMarkdown(); // force a render after saving, in case stale content is in preview
  markSaved();      // explicitly mark as saved AFTER rendering
}

function getFileData(filename) {
  try {
    // Try the new format first
    const data = localStorage.getItem('mdfile_' + filename);
    if (data) {
      return JSON.parse(data);
    }
    
    // Fall back to old format if needed
    const content = localStorage.getItem('mdcontent_' + filename);
    const statesStr = localStorage.getItem('mdstate_' + filename);
    const states = statesStr ? JSON.parse(statesStr) : [];
    
    // Convert to new format
    return {
      content: content || '',
      category: 'Migrated',
      checkboxStates: states,
      created: new Date().toISOString(),
      modified: new Date().toISOString()
    };
  } catch (e) {
    console.error('Error getting file data:', e);
    return {
      content: '',
      category: 'Uncategorized',
      checkboxStates: [],
      created: new Date().toISOString(),
      modified: new Date().toISOString()
    };
  }
}

function loadSavedFile() {
  const file = savedFilesDropdown.value;
  if (!file) return;
  
  // Warn if current file has unsaved changes
  if (hasUnsavedChanges && !confirm('You have unsaved changes. Load another file anyway?')) {
    return;
  }
  
  currentFile = file;
  const fileData = getFileData(file);
  
  markdownInput.value = fileData.content || '';
  originalContent = markdownInput.value;
  renderMarkdown();
  //console.log('[renderMarkdown] input:', markdownInput.value); //this and next two lines are for troubleshooting 
  //console.log('[renderMarkdown] original:', originalContent);
  //console.log('[renderMarkdown] equal?', markdownInput.value === originalContent);
  setTimeout(restoreCheckboxStates, 100);
  updateFileMetadata(fileData);
  showStatus(`Loaded ${file}`);
  markSaved();
  
  // Hide editor when loading a file
  if (editorVisible) {
    toggleEditor();
  }
}

function deleteSavedFile() {
  if (!currentFile) {
    showStatus('No file selected', true);
    return;
  }
  
  if (confirm(`Are you sure you want to delete "${currentFile}"?`)) {
    // Remove both old and new format storage
    localStorage.removeItem('mdfile_' + currentFile);
    localStorage.removeItem('mdcontent_' + currentFile);
    localStorage.removeItem('mdstate_' + currentFile);
    
    updateSavedFilesList();
    updateCategoriesList();
    
    markdownInput.value = '';
    rendered.innerHTML = '';
    currentFile = '';
    fileMetadata.innerHTML = '';
    originalContent = '';
    
    showStatus(`Deleted file`);
    markSaved();
  }
}

function handleFileUpload(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  // Warn if current file has unsaved changes
  if (hasUnsavedChanges && !confirm('You have unsaved changes. Load a new file anyway?')) {
    event.target.value = '';
    return;
  }
  
  const reader = new FileReader();
  reader.onload = function(e) {
    markdownInput.value = e.target.result;
    currentFile = file.name;
    originalContent = markdownInput.value;
    renderMarkdown();
    showStatus(`Loaded ${file.name} from disk`);
    document.getElementById('fileInput').value = '';
    markSaved();
    
    // Automatically hide editor after upload is complete
    if (editorVisible) {
      toggleEditor();
    }
  };
  reader.readAsText(file);
}

function exportCurrentFile() {
  if (!markdownInput.value) {
    showStatus('Nothing to export', true);
    return;
  }
  
  const checkboxes = rendered.querySelectorAll('input[type="checkbox"]');
  let mdContent = markdownInput.value;
  let mdLines = mdContent.split('\n');
  let checkboxIndex = 0;
  
  for (let i = 0; i < mdLines.length; i++) {
    if (mdLines[i].includes('- [ ]') || mdLines[i].includes('- [x]')) {
      const isChecked = checkboxIndex < checkboxes.length && checkboxes[checkboxIndex].checked;
      mdLines[i] = mdLines[i].replace(/- \[[x ]\]/i, isChecked ? '- [x]' : '- [ ]');
      checkboxIndex++;
    }
  }
  
  const updatedMd = mdLines.join('\n');
  const blob = new Blob([updatedMd], {type: 'text/markdown'});
  const url = URL.createObjectURL(blob);
  
  const a = document.createElement('a');
  a.href = url;
  a.download = currentFile || 'markdown_export.md';
  a.click();
  
  URL.revokeObjectURL(url);
  showStatus(`Exported to ${currentFile || 'markdown_export.md'}`);
}

// New function to get categories
function getCategories() {
  let categories = initializeCategories();
  
  // Also scan files for any categories not in our list
  Object.keys(localStorage).forEach(key => {
    if (key.startsWith('mdfile_')) {
      try {
        const data = JSON.parse(localStorage.getItem(key));
        if (data.category && !categories.includes(data.category)) {
          categories.push(data.category);
        }
      } catch (e) {
        console.error('Error parsing file data:', e);
      }
    }
  });
  
  return categories;
}

// New function to add a category
function addCategory(category) {
  if (!category || category.trim() === '') return;
  
  category = category.trim();
  const categories = getCategories();
  
  if (!categories.includes(category)) {
    categories.push(category);
    saveCategories(categories);
    return true;
  }
  
  return false;
}

function updateSavedFilesList() {
  savedFilesDropdown.innerHTML = '<option value="">-- Select a file --</option>';
  
  // Get all files (from both old and new storage formats)
  const files = [];
  Object.keys(localStorage).forEach(key => {
    if (key.startsWith('mdfile_')) {
      files.push(key.replace('mdfile_', ''));
    } else if (key.startsWith('mdcontent_')) {
      const filename = key.replace('mdcontent_', '');
      if (!files.includes(filename)) {
        files.push(filename);
      }
    }
  });
  
  // Filter by category if needed
  let filesToShow = files;
  if (currentCategory !== 'all') {
    filesToShow = files.filter(filename => {
      const fileData = getFileData(filename);
      return fileData.category === currentCategory;
    });
  }
  
  // Sort alphabetically
  filesToShow.sort();
  
  // Add to dropdown
  filesToShow.forEach(filename => {
    const option = document.createElement('option');
    option.value = filename;
    option.textContent = filename;
    // Select current file
    if (filename === currentFile) {
      option.selected = true;
    }
    savedFilesDropdown.appendChild(option);
  });
  
  // Show count in status
  showStatus(`${filesToShow.length} files in view (${files.length} total)`);
}

// Replace the existing updateCategoriesList function with this one
function updateCategoriesList() {
  // Get all categories from our storage and scan for any missing ones
  const categories = getCategories();
  
  // Update dropdown
  categoryDropdown.innerHTML = '<option value="all">All Categories</option>';
  categories.forEach(category => {
    const option = document.createElement('option');
    option.value = category;
    option.textContent = category;
    if (category === currentCategory) {
      option.selected = true;
    }
    categoryDropdown.appendChild(option);
  });
  
  // Update tags display
  categoriesList.innerHTML = '';
  categories.forEach(category => {
    // Create container for the category and its files
    const categoryContainer = document.createElement('div');
    categoryContainer.className = 'category-container';
    
    // Create the category tag
    const tag = document.createElement('div');
    tag.className = 'category-tag';
    if (category === currentCategory) {
      tag.className += ' active';
    }
    tag.textContent = category;
    tag.onclick = () => {
      // Toggle the display of files
      const filesList = categoryContainer.querySelector('.category-files');
      if (filesList.classList.contains('hidden')) {
        // Hide all other file lists first
        document.querySelectorAll('.category-files').forEach(el => {
          el.classList.add('hidden');
        });
        // Show this one
        filesList.classList.remove('hidden');
      } else {
        filesList.classList.add('hidden');
      }
    };
    
    // Create the files list container (initially hidden)
    const filesList = document.createElement('div');
    filesList.className = 'category-files hidden';
    
    // Add files that belong to this category
    let filesInCategory = getFilesInCategory(category);
    if (filesInCategory.length > 0) {
      filesInCategory.forEach(filename => {
        const fileItem = document.createElement('div');
        fileItem.className = 'file-bubble';
        fileItem.textContent = filename;
        fileItem.onclick = (e) => {
          e.stopPropagation(); // Prevent triggering the category click
          loadSpecificFile(filename);
        };
        filesList.appendChild(fileItem);
      });
    } else {
      const emptyItem = document.createElement('div');
      emptyItem.className = 'file-bubble empty';
      emptyItem.textContent = 'No files';
      filesList.appendChild(emptyItem);
    }
    
    categoryContainer.appendChild(tag);
    categoryContainer.appendChild(filesList);
    categoriesList.appendChild(categoryContainer);
  });
}

// Add this new function to get files in a category
function getFilesInCategory(category) {
  const filesInCategory = [];
  
  Object.keys(localStorage).forEach(key => {
    if (key.startsWith('mdfile_')) {
      const filename = key.replace('mdfile_', '');
      const fileData = getFileData(filename);
      if (fileData.category === category) {
        filesInCategory.push(filename);
      }
    }
  });
  
  // Sort files alphabetically
  return filesInCategory.sort();
}

// Add this new function to load a specific file when clicked
function loadSpecificFile(filename) {
  // Warn if current file has unsaved changes
  if (hasUnsavedChanges && !confirm('You have unsaved changes. Load another file anyway?')) {
    return;
  }
  
  currentFile = filename;
  const fileData = getFileData(filename);
  
  markdownInput.value = fileData.content || '';
  originalContent = markdownInput.value;
  renderMarkdown();
  setTimeout(restoreCheckboxStates, 100);
  updateFileMetadata(fileData);
  showStatus(`Loaded ${filename}`);
  markSaved();
  
  // Hide editor when loading a file (if you want this behavior)
  if (editorVisible) {
    toggleEditor();
  }
}

function createCategory() {
  const category = prompt('Enter a new category name:');
  if (category && category.trim()) {
    const newCategory = category.trim();
    
    // Add the category to our storage
    if (addCategory(newCategory)) {
      currentCategory = newCategory;
      updateCategoriesList();
      updateSavedFilesList();
      showStatus(`Category "${newCategory}" created`);
    } else {
      showStatus(`Category "${newCategory}" already exists`, true);
    }
  }
}

// New function to delete a category
function deleteCategory() {
  if (currentCategory === 'all') {
    showStatus('Please select a category to delete', true);
    return;
  }
  
  if (currentCategory === 'Uncategorized') {
    showStatus('Cannot delete the default category', true);
    return;
  }
  
  if (confirm(`Are you sure you want to delete the category "${currentCategory}"?`)) {
    // Get all files in this category
    const filesInCategory = [];
    Object.keys(localStorage).forEach(key => {
      if (key.startsWith('mdfile_')) {
        const filename = key.replace('mdfile_', '');
        const fileData = getFileData(filename);
        if (fileData.category === currentCategory) {
          filesInCategory.push(filename);
        }
      }
    });
    
    // If there are files in this category, show options
    if (filesInCategory.length > 0) {
      showCategoryDeletionOptions(filesInCategory);
    } else {
      // No files, just delete the category
      deleteSelectedCategory();
    }
  }
}

// Function to show modal with category deletion options
function showCategoryDeletionOptions(filesInCategory) {
  // Create modal container
  const modalContainer = document.createElement('div');
  modalContainer.className = 'modal-container';
  
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.maxWidth = '500px';
  
  const title = document.createElement('h3');
  title.textContent = `There are ${filesInCategory.length} files in category "${currentCategory}"`;
  
  const subtitle = document.createElement('p');
  subtitle.textContent = 'What would you like to do with these files?';
  
  // Create options
  const optionsContainer = document.createElement('div');
  optionsContainer.style.margin = '1rem 0';
  
  // Option 1: Move to Uncategorized
  const option1 = document.createElement('div');
  option1.className = 'file-item';
  
  const radio1 = document.createElement('input');
  radio1.type = 'radio';
  radio1.name = 'category-deletion-option';
  radio1.id = 'option-uncategorized';
  radio1.value = 'uncategorized';
  radio1.checked = true;
  
  const label1 = document.createElement('label');
  label1.htmlFor = 'option-uncategorized';
  label1.textContent = 'Move files to "Uncategorized"';
  label1.style.marginLeft = '0.5rem';
  label1.style.cursor = 'pointer';
  
  option1.appendChild(radio1);
  option1.appendChild(label1);
  optionsContainer.appendChild(option1);
  
  // Get all categories except the current one
  const categories = getCategories().filter(cat => 
    cat !== currentCategory && cat !== 'Uncategorized' // Exclude both current category and Uncategorized
  );
  
  // Create radio buttons for all other existing categories
  categories.forEach((category, index) => {
    const optionItem = document.createElement('div');
    optionItem.className = 'file-item';
    
    const radio = document.createElement('input');
    radio.type = 'radio';
    radio.name = 'category-deletion-option';
    radio.id = `option-category-${index}`;
    radio.value = `category-${category}`;
    
    const label = document.createElement('label');
    label.htmlFor = `option-category-${index}`;
    label.textContent = `Move files to "${category}"`;
    label.style.marginLeft = '0.5rem';
    label.style.cursor = 'pointer';
    
    optionItem.appendChild(radio);
    optionItem.appendChild(label);
    optionsContainer.appendChild(optionItem);
  });
  
  // Option: Delete files
  const optionDelete = document.createElement('div');
  optionDelete.className = 'file-item';
  optionDelete.style.marginTop = '1rem';
  
  const radioDelete = document.createElement('input');
  radioDelete.type = 'radio';
  radioDelete.name = 'category-deletion-option';
  radioDelete.id = 'option-delete-files';
  radioDelete.value = 'delete-files';
  
  const labelDelete = document.createElement('label');
  labelDelete.htmlFor = 'option-delete-files';
  labelDelete.textContent = 'Delete all files in this category';
  labelDelete.style.marginLeft = '0.5rem';
  labelDelete.style.cursor = 'pointer';
  labelDelete.style.color = '#e74c3c';
  
  optionDelete.appendChild(radioDelete);
  optionDelete.appendChild(labelDelete);
  optionsContainer.appendChild(optionDelete);
  
  // Buttons
  const buttonGroup = document.createElement('div');
  buttonGroup.className = 'modal-buttons';
  
  const confirmBtn = document.createElement('button');
  confirmBtn.textContent = 'Confirm';
  confirmBtn.style.marginRight = '0.5rem';
  
  const cancelBtn = document.createElement('button');
  cancelBtn.textContent = 'Cancel';
  
  buttonGroup.appendChild(confirmBtn);
  buttonGroup.appendChild(cancelBtn);
  
  // Assemble the modal
  modal.appendChild(title);
  modal.appendChild(subtitle);
  modal.appendChild(optionsContainer);
  modal.appendChild(buttonGroup);
  modalContainer.appendChild(modal);
  document.body.appendChild(modalContainer);
  
  // Button event handlers
  cancelBtn.addEventListener('click', () => {
    document.body.removeChild(modalContainer);
  });
  
  confirmBtn.addEventListener('click', () => {
    const selectedOption = document.querySelector('input[name="category-deletion-option"]:checked').value;
    
    if (selectedOption === 'uncategorized') {
      // Move files to Uncategorized
      filesInCategory.forEach(filename => {
        const fileData = getFileData(filename);
        fileData.category = 'Uncategorized';
        localStorage.setItem('mdfile_' + filename, JSON.stringify(fileData));
      });
      showStatus(`${filesInCategory.length} files moved to "Uncategorized"`);
    } 
    else if (selectedOption.startsWith('category-')) {
      // Move files to selected category
      const targetCategory = selectedOption.replace('category-', '');
      filesInCategory.forEach(filename => {
        const fileData = getFileData(filename);
        fileData.category = targetCategory;
        localStorage.setItem('mdfile_' + filename, JSON.stringify(fileData));
      });
      showStatus(`${filesInCategory.length} files moved to "${targetCategory}"`);
    }
    else if (selectedOption === 'delete-files') {
      // Delete all files if confirmed
      if (confirm(`Are you sure you want to delete ${filesInCategory.length} files? This cannot be undone.`)) {
        filesInCategory.forEach(filename => {
          localStorage.removeItem('mdfile_' + filename);
          localStorage.removeItem('mdcontent_' + filename);
          localStorage.removeItem('mdstate_' + filename);
          
          if (currentFile === filename) {
            currentFile = '';
            markdownInput.value = '';
            rendered.innerHTML = '';
            fileMetadata.innerHTML = '';
            originalContent = '';
            markSaved();
          }
        });
        showStatus(`${filesInCategory.length} files deleted`);
      } else {
        // User canceled file deletion
        document.body.removeChild(modalContainer);
        return;
      }
    }
    
    // Delete the category and update UI
    deleteSelectedCategory();
    document.body.removeChild(modalContainer);
  });
}

// Function to delete the currently selected category
function deleteSelectedCategory() {
  const categories = getCategories();
  const updatedCategories = categories.filter(cat => cat !== currentCategory);
  saveCategories(updatedCategories);
  
  // Reset to "all" view
  currentCategory = 'all';
  updateCategoriesList();
  updateSavedFilesList();
  
  showStatus(`Category "${currentCategory}" deleted`);
}

function filterByCategory() {
  currentCategory = categoryDropdown.value;
  updateCategoriesList();
  updateSavedFilesList();
}

function updateStatusBar(message, isError = false) {
  if (message) {
    showStatus(message, isError);
  } else {
    // Just update the checkbox count
    const checkboxes = rendered.querySelectorAll('input[type="checkbox"]');
    const checkedCount = Array.from(checkboxes).filter(cb => cb.checked).length;
    
    if (checkboxes.length > 0) {
      statusBar.textContent = `${checkedCount}/${checkboxes.length} tasks complete`;
    } else {
      statusBar.textContent = hasUnsavedChanges ? 'Unsaved changes' : 'Ready';
    }
  }
}

function updateFileMetadata(fileData) {
  if (!fileData || !currentFile) {
    fileMetadata.innerHTML = '';
    return;
  }
  
  const created = fileData.created ? new Date(fileData.created).toLocaleString() : 'Unknown';
  const modified = fileData.modified ? new Date(fileData.modified).toLocaleString() : 'Unknown';
  
  fileMetadata.innerHTML = `
    <strong>${currentFile}</strong> | 
    Category: <span style="color: #4a90e2">${fileData.category || 'Uncategorized'}</span> | 
    Created: ${created} | 
    Modified: ${modified}
  `;
}

function cleanupStorage() {
  if (confirm('This will show all saved files for deletion. Continue?')) {
    const files = [];
    
    // Collect all files
    Object.keys(localStorage).forEach(key => {
      if (key.startsWith('mdfile_')) {
        const filename = key.replace('mdfile_', '');
        const fileData = getFileData(filename);
        files.push({ 
          name: filename, 
          category: fileData.category || 'Uncategorized',
          modified: fileData.modified || 'Unknown' 
        });
      } else if (key.startsWith('mdcontent_')) {
        const filename = key.replace('mdcontent_', '');
        if (!localStorage.getItem('mdfile_' + filename)) {
          files.push({ 
            name: filename, 
            category: 'Legacy Format',
            modified: 'Unknown' 
          });
        }
      }
    });
    
    if (files.length === 0) {
      showStatus('No files to clean up', true);
      return;
    }
    
    // Sort files by name
    files.sort((a, b) => a.name.localeCompare(b.name));
    
    // Create modal
    const modalContainer = document.createElement('div');
    modalContainer.className = 'modal-container';
    
    const modal = document.createElement('div');
    modal.className = 'modal';
    
    const title = document.createElement('h3');
    title.textContent = 'Select files to delete:';
    
    const fileList = document.createElement('div');
    fileList.style.maxHeight = '400px';
    fileList.style.overflowY = 'auto';
    fileList.style.margin = '1rem 0';
    
    files.forEach(file => {
      const fileItem = document.createElement('div');
      fileItem.className = 'file-item';
      
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.dataset.filename = file.name;
      
      const fileInfo = document.createElement('div');
      fileInfo.className = 'file-item-info';
      fileInfo.textContent = file.name;
      
      const fileCategory = document.createElement('div');
      fileCategory.className = 'file-item-category';
      fileCategory.textContent = file.category;
      
      fileItem.appendChild(checkbox);
      fileItem.appendChild(fileInfo);
      fileItem.appendChild(fileCategory);
      fileList.appendChild(fileItem);
    });
    
    const buttonGroup = document.createElement('div');
    buttonGroup.className = 'modal-buttons';
    
    const selectAllBtn = document.createElement('button');
    selectAllBtn.textContent = 'Select All';
    selectAllBtn.style.marginRight = '0.5rem';
    
    const deleteBtn = document.createElement('button');
    deleteBtn.textContent = 'Delete Selected';
    deleteBtn.style.marginRight = '0.5rem';
    
    const cancelBtn = document.createElement('button');
    cancelBtn.textContent = 'Cancel';
    
    buttonGroup.appendChild(selectAllBtn);
    buttonGroup.appendChild(deleteBtn);
    buttonGroup.appendChild(cancelBtn);
    
    modal.appendChild(title);
    modal.appendChild(fileList);
    modal.appendChild(buttonGroup);
    modalContainer.appendChild(modal);
    
    document.body.appendChild(modalContainer);
    
    // Event handlers
    selectAllBtn.addEventListener('click', () => {
      const checkboxes = fileList.querySelectorAll('input[type="checkbox"]');
      const allChecked = Array.from(checkboxes).every(cb => cb.checked);
      checkboxes.forEach(cb => cb.checked = !allChecked);
    });
    
    cancelBtn.addEventListener('click', () => {
      document.body.removeChild(modalContainer);
    });
    
    deleteBtn.addEventListener('click', () => {
      const checkboxes = fileList.querySelectorAll('input[type="checkbox"]:checked');
      if (checkboxes.length === 0) {
        alert('No files selected.');
        return;
      }
      
      if (confirm(`Delete ${checkboxes.length} selected file(s)?`)) {
        let deletedFiles = 0;
        
        checkboxes.forEach(checkbox => {
          const filename = checkbox.dataset.filename;
          localStorage.removeItem('mdfile_' + filename);
          localStorage.removeItem('mdcontent_' + filename);
          localStorage.removeItem('mdstate_' + filename);
          
          if (currentFile === filename) {
            currentFile = '';
            markdownInput.value = '';
            rendered.innerHTML = '';
            fileMetadata.innerHTML = '';
            originalContent = '';
            markSaved();
          }
          
          deletedFiles++;
        });
        
        updateSavedFilesList();
        updateCategoriesList();
        document.body.removeChild(modalContainer);
        showStatus(`${deletedFiles} file(s) deleted`);
      }
    });
  }
}

// Migration function for old storage format
function migrateOldData() {
  let migrated = 0;
  
  Object.keys(localStorage).forEach(key => {
    if (key.startsWith('mdcontent_')) {
      const filename = key.replace('mdcontent_', '');
      // Check if already migrated
      if (!localStorage.getItem('mdfile_' + filename)) {
        const content = localStorage.getItem(key);
        const statesStr = localStorage.getItem('mdstate_' + filename);
        const states = statesStr ? JSON.parse(statesStr) : [];
        
        // Create new format
        const fileData = {
          content: content,
          category: 'Migrated',
          checkboxStates: states,
          created: new Date().toISOString(),
          modified: new Date().toISOString()
        };
        
        localStorage.setItem('mdfile_' + filename, JSON.stringify(fileData));
        migrated++;
      }
    }
  });
  
  if (migrated > 0) {
    showStatus(`Migrated ${migrated} files to new format`);
  }
}

// Add a warning when leaving with unsaved changes
window.addEventListener('beforeunload', (e) => {
  if (hasUnsavedChanges) {
    e.preventDefault();
    e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
    return e.returnValue;
  }
});

// Add keyboard shortcut for toggling editor visibility
document.addEventListener('keydown', function(event) {
  // Ctrl+E or Cmd+E to toggle editor
  if ((event.ctrlKey || event.metaKey) && event.key === 'e') {
    event.preventDefault();
    toggleEditor();
  }
});

// On load
if (localStorage.getItem('darkMode') === 'true') {
  document.body.classList.add('dark-mode');
}

migrateOldData();
updateSavedFilesList();
updateCategoriesList();
initializeDisplayMode();
renderMarkdown();

// Add a helper tooltip about editor toggle keyboard shortcut
const shortcutInfo = document.createElement('div');
shortcutInfo.style.position = 'fixed';
shortcutInfo.style.bottom = '10px';
shortcutInfo.style.right = '10px';
shortcutInfo.style.background = 'rgba(0,0,0,0.7)';
shortcutInfo.style.color = 'white';
shortcutInfo.style.padding = '5px 10px';
shortcutInfo.style.borderRadius = '4px';
shortcutInfo.style.fontSize = '12px';
shortcutInfo.style.zIndex = '1000';
shortcutInfo.style.opacity = '0.7';
shortcutInfo.textContent = 'Tip: Press Ctrl+E to toggle editor';
document.body.appendChild(shortcutInfo);

setTimeout(() => {
  shortcutInfo.style.opacity = '0';
  shortcutInfo.style.transition = 'opacity 1s';
  setTimeout(() => document.body.removeChild(shortcutInfo), 1000);
}, 5000);
</script>

</body>
</html>